\section{Sortieren}
\rule{\textwidth}{0.4pt}
\subsubsection*{Formaler} Gegeben: Elementfolge $s = [e_1, \cdots, e_n]$ \\ Gesucht: $s' = [e'_1, \cdots, e'_n]$
\begin{itemize}
    \item $s'$ ist Permutation von $s$
    \item $e'_1 \leq \cdots \leq e'_n$ für eine \textbf{lineare Ordnung $'\leq'$}
\end{itemize}
\subsubsection*{Anwendungsbeispiele}
\begin{itemize}
    \item Allgemein: Vorverarbeitung
    \item Suche: \textbf{Telefonbuch} $\leftrightarrow$ unsortierte Liste
    \item Gruppieren (Alternative Hashing?)
\end{itemize}

\subsubsection*{Beispiel aus Kurs/ Buch}
\begin{itemize}
    \item Aufabau von Suchbäumen 
    \item Kruskals MST- Algorithmus
    \item Verarbeitung von Intervallgraphen (z.B Hotelbuchungen)
    \item Rucksackproblem
    \item Scheduling, die schwersten Probleme zuerst
    \item Sekundärspeicheralgorithmen, z.B Datenbank-Join
\end{itemize}
Viele verwandte Probleme. Zum Beisoiel \textbf{Transposition} dünner Matrizen, \textbf{invertierten Index} aufbauen, Konversion zwischen Graphrepräsentationen.
\subsubsection*{Überblick}
\begin{itemize}
    \item Einfache Algorithmen/ kleine Datenmengen
    \item \textbf{Mergesort} - ein erster effizienter Algorithmus
    \item Eine passende \textbf{untere Schranke}
    \item \textbf{Quicksort}
    \item das Asuwahlproblem
    \item ganzzahlige Slüssel - jenseits der unteren Schranke
\end{itemize}

\subsection{Einfache Sortieralgorithmen}
\subsubsection*{Sortieren durch Einfügen (inster sort)}
\begin{algorithmic}
    \Procedure{MyAlgorithm}{$x$}
      \State $y \gets 0$
      \For{$i \gets 1$ to $10$}
        \If{$i$ is odd}
          \State $y \gets y + x$
        \EndIf
      \EndFor
      \State \textbf{return} $y$
    \EndProcedure
  \end{algorithmic}

  \subsubsection*{Sentinels am Beispiel Sortieren durch Einfügen}
  
  \begin{algorithmic}
    \Procedure{insertSort}{$a$ : Array [1..n] of Elements}
      \For{$i \gets 2$ to $n$ do}
        \State \textbf{invariant} $a[1] \leq \ldots \leq a[i-1]$
        $\cdots$
      \EndFor
      \State \textbf{return} $y$
    \EndProcedure
  \end{algorithmic}

  \subsubsection*{Analyse}

  \subsection{Sortieren durch Mischen}
  \textbf{idee:} Teile und Hersche \\

  \begin{algorithmic}
    \Procedure{mergSort}{[$e_1, \cdots, e_n$] : Sequence of Elements}
    \If{$n = 1$} 
    \State \textbf{return} $[e_1]$
    \EndIf
    \EndProcedure
  \end{algorithmic}

  \subsubsection*{Mischen(merge)}
  \subsubsection*{Beispiel}
  \subsubsection*{Mischen}
  \subsubsection*{Analyse}
  \[T(n) = O(n) + T(\lceil n / w \rceil ) + T(\lfloor n / s \rfloor )\]

  Problem: Runderei

  \subsection{Untere Schranken}
  geht es schneller als $\Theta (n log n)$?

  \subsubsection*{Eine vergleisbasiere untere Schranke}
  Vergkeichsbasiertes Sortieren: Informationen über Elemente nur durch Zwei-Wege-Vergleich $e_i \leq e_j$? 
  \begin{itemize}
    \item [Satz: ] Deterministische vergleichsbasierte Sortieralgorithmen brauchen \[\textbf{n log n} - O(n)\] Vergleiche im schlechtesten Fall.
    \item [Beweis: ] Betrachte Eingaben, die Permutatuiónen von $1..n$ sin. Es gibt genau $n!$ solche Permutationen.
  \end{itemize}

  \subsubsection*{Baumbasierte Sortierer-Darstellung}

  \subsubsection*{Beweis}
  Baum der \textbf{Tiefe T} hat höchstens $2^T$ Blätter. \[\Rightarrow 2^T \geq n!\]\[\Leftrightarrow T \geq \log n! \geq \log (\frac{n}{e})^n = n \log n - n \log e = n \log n - O(n)\] einfache Aproximation der Fakultät: $(\frac{n}{e})^n \leq n! \leq n^n$ \\ Beweis für den \textbf{linken Teil:} \[\ln n ! = \sum\limits_{2 \leq i \leq n} \ln i \geq \int\limits_{1}^{n} \ln x \, dx = [x (\ln x - 1)]_{x = 1}^{x = n} \geq n(\ln n -1)\] \[n! \geq e^{n(\ln n - 1)} = \frac{e^{n\ln n}}{e^n} = \frac{n^n}{e^n} = (\frac{n}{e})^n\]

  \subsubsection*{Randomisierung, Mittlere Auführungszeit}
  
  \textbf{Satz:} immer noch $n \log n - O(n)$ Vergleiche. \\ \textbf{Beweis:} nicht hier.

  \subsection*{Quicksort - erster Versuch}
  \textbf{Idee:} Teile-und-Hersche aber vergleichen mit mergsort "andersrum"- Leiste Arbeit \textbf{vor} rekursivem Aufruf
  %\begin{algorithmic}
    
  %\end{algorithmic}

  \subsection*{Quicksort - Analyse im
  schlechtesten Fall}

  \textbf{Annahme: }Pivot ist immer Minimum (oder Maximum) der Eingaben\[ T(n) = 
    \begin{cases}
        \Theta (1) & \text{if } n = 1 \\
        \Theta (n) & \text{if } n \geq 2 \\
    \end{cases} \] $\Rightarrow T (n) = \Theta (n + (n - 1) + \cdots + 1) = \Theta(n^2)$

    \subsubsection*{Schlechteser Fall: Beispiel}

    \subsection*{Quicksort - Analyse im besten Fall}
